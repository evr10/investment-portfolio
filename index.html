<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Fidelity Portfolio Overview (PDF Holdings + CSV Transactions)</title>

  <!-- CSV parsing -->
  <script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>
  <!-- Charts -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>

  <!-- PDF.js (browser) -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/4.0.379/pdf.min.js"></script>

  <style>
    :root { --bg:#0b1020; --card:#121a33; --text:#e8ecff; --muted:#a7b0d6; --accent:#7aa2ff; --line:#27325f; }
    body { margin:0; font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial; background:var(--bg); color:var(--text); }
    header { padding:24px 16px; border-bottom:1px solid var(--line); }
    h1 { margin:0 0 8px 0; font-size:20px; }
    p { margin:0; color:var(--muted); line-height:1.4; }
    main { padding:16px; max-width:1200px; margin:0 auto; }
    .grid { display:grid; grid-template-columns: 1fr; gap:12px; }
    @media (min-width: 980px){ .grid { grid-template-columns: 1.2fr 0.8fr; } }
    .card { background:var(--card); border:1px solid var(--line); border-radius:14px; padding:14px; }
    .row { display:flex; gap:10px; flex-wrap:wrap; align-items:center; }
    label { font-size:12px; color:var(--muted); display:block; margin-bottom:6px; }
    input[type=file] { width:100%; padding:10px; border-radius:10px; border:1px dashed var(--line); background:#0f1630; color:var(--muted); }
    button { padding:10px 12px; border-radius:10px; border:1px solid var(--line); background:#0f1630; color:var(--text); cursor:pointer; }
    button:hover { border-color:var(--accent); }
    .kpis { display:grid; grid-template-columns: repeat(2, minmax(0,1fr)); gap:10px; }
    @media (min-width: 700px){ .kpis { grid-template-columns: repeat(4, minmax(0,1fr)); } }
    .kpi { padding:10px; border:1px solid var(--line); border-radius:12px; background:#0f1630; }
    .kpi .v { font-size:16px; font-weight:700; margin-top:4px; }
    .kpi .t { font-size:12px; color:var(--muted); }
    .pill { display:inline-block; padding:2px 8px; border-radius:999px; border:1px solid var(--line); color:var(--muted); font-size:11px; }
    .warn { color:#ffd27a; font-size:12px; margin-top:8px; white-space:pre-wrap; }
    table { width:100%; border-collapse:collapse; }
    th, td { padding:10px 8px; border-bottom:1px solid var(--line); font-size:12px; text-align:right; white-space:nowrap; }
    th { color:var(--muted); font-weight:600; position:sticky; top:0; background:var(--card); }
    th:first-child, td:first-child { text-align:left; }
    .search { width:100%; padding:10px; border-radius:10px; border:1px solid var(--line); background:#0f1630; color:var(--text); }
    .small { font-size:12px; color:var(--muted); }
    .split { display:grid; grid-template-columns: 1fr; gap:12px; }
    @media (min-width: 980px){ .split { grid-template-columns: 1fr 1fr; } }
    code { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace; }
  </style>
</head>
<body>
<header>
  <h1>Fidelity Portfolio Overview</h1>
  <p>Upload <b>PDF statements</b> (holdings only) + a <b>transactions CSV</b>. Auto-detects file type. Runs fully in your browser.</p>
</header>

<main>
  <div class="grid">
    <div class="card">
      <h2 style="margin:0 0 10px 0; font-size:16px;">Upload</h2>
      <label>Upload files (PDF statements + CSV transactions). You can select multiple at once.</label>
      <input id="fileInput" type="file" accept=".pdf,.csv" multiple />

      <div class="row" style="margin-top:10px;">
        <button id="processBtn">Process uploads</button>
        <button id="loadDemoBtn">Load demo</button>
        <button id="resetBtn">Reset</button>
        <span class="pill" id="statusPill">Waiting for uploads…</span>
      </div>

      <div class="small" style="margin-top:10px;">
        <div><b>PDF parsing scope:</b> holdings only (no activity parsing).</div>
        <div><b>CSV expectation:</b> transactions with buy/sell amounts (header mapping is flexible).</div>
      </div>

      <div class="warn" id="warnBox"></div>

      <hr style="border:none; border-top:1px solid var(--line); margin:14px 0;" />

      <h2 style="margin:0 0 10px 0; font-size:16px;">Summary</h2>
      <div class="kpis">
        <div class="kpi"><div class="t">Start Value (earliest statement)</div><div class="v" id="kpiStart">—</div></div>
        <div class="kpi"><div class="t">End Value (latest statement)</div><div class="v" id="kpiEnd">—</div></div>
        <div class="kpi"><div class="t">Net Flow (Buys − Sells)</div><div class="v" id="kpiFlow">—</div></div>
        <div class="kpi"><div class="t">Market Growth</div><div class="v" id="kpiGrowth">—</div></div>
      </div>

      <div class="small" style="margin-top:10px;">
        Market Growth = End − Start − Net Flow.
        If you upload only one statement, you’ll see holdings but growth won’t compute.
      </div>

      <div class="small" style="margin-top:10px;">
        <b>Loaded snapshots:</b> <span id="snapshotsInfo">none</span><br/>
        <b>Loaded transactions:</b> <span id="txInfo">none</span>
      </div>
    </div>

    <div class="card">
      <h2 style="margin:0 0 10px 0; font-size:16px;">Charts</h2>
      <div class="split">
        <div>
          <div class="small" style="margin-bottom:6px;">Top tickers by Market Growth</div>
          <canvas id="growthChart" height="220"></canvas>
        </div>
        <div>
          <div class="small" style="margin-bottom:6px;">Buys vs Sells (total)</div>
          <canvas id="flowChart" height="220"></canvas>
        </div>
      </div>
      <div class="small" style="margin-top:10px;">
        If a ticker exists in statements but not transactions (or vice versa), it still appears.
      </div>
    </div>
  </div>

  <div class="card" style="margin-top:12px;">
    <div class="row" style="justify-content:space-between;">
      <div>
        <h2 style="margin:0; font-size:16px;">Ticker breakdown</h2>
        <div class="small">Search tickers. Export the computed table.</div>
      </div>
      <div class="row">
        <input id="searchBox" class="search" placeholder="Search ticker (e.g., MSFT, VOO, SPAXX)…" style="width:260px;" />
        <button id="exportBtn">Export CSV</button>
      </div>
    </div>

    <div style="overflow:auto; margin-top:10px; max-height:520px;">
      <table id="tbl">
        <thead>
          <tr>
            <th>Symbol</th>
            <th>Start Value</th>
            <th>End Value</th>
            <th>Buys</th>
            <th>Sells</th>
            <th>Net Flow</th>
            <th>Market Growth</th>
          </tr>
        </thead>
        <tbody></tbody>
      </table>
    </div>

    <div class="small" id="tableNote" style="margin-top:10px;"></div>
  </div>
</main>

<script>
/** ========= Utilities ========= **/
const $ = (id) => document.getElementById(id);
const fmt = (n) => (Number.isFinite(n) ? n.toLocaleString(undefined, {style:"currency", currency:"USD"}) : "—");
const num = (v) => {
  if (v === null || v === undefined) return NaN;
  if (typeof v === "number") return v;
  const s = String(v).replace(/[$,]/g,"").trim();
  if (!s) return NaN;
  return Number(s);
};
const normSym = (s) => String(s || "").trim().toUpperCase();
function setStatus(text){ $("statusPill").textContent = text; }
function warn(msg){ $("warnBox").textContent = msg || ""; }

/** ========= Global state ========= **/
let snapshots = []; // [{ endDate: Date, endDateLabel: "YYYY-MM-DD", bySymbol: Map(symbol -> value), sourceName }]
let txAgg = { bySym: new Map(), warnings: [] };
let mergedRows = [];
let growthChart, flowChart;

/** ========= CSV: Transactions parsing =========
  Adjust mapping here if your Fidelity export differs.
**/
const TX_FIELDS = {
  date: ["Date", "Trade Date", "Run Date", "Settlement Date"],
  action: ["Action", "Transaction", "Type", "Description"],
  symbol: ["Symbol", "Ticker", "Security", "Investment"],
  quantity: ["Quantity", "Shares", "Units"],
  amount: ["Amount", "Net Amount", "Value", "Total", "Principal"],
  price: ["Price", "Share Price"]
};
function pickField(row, candidates){
  for (const c of candidates){
    if (c in row) return row[c];
  }
  return undefined;
}
function classifyAction(raw){
  const a = String(raw || "").toLowerCase();
  if (a.includes("buy")) return "BUY";
  if (a.includes("sell")) return "SELL";
  return "OTHER";
}
function parseTransactionsCsv(rows){
  const bySym = new Map();
  const warnings = [];

  for (const r of rows){
    const sym = normSym(pickField(r, TX_FIELDS.symbol));
    if (!sym) continue;

    const action = classifyAction(pickField(r, TX_FIELDS.action));
    const qty = num(pickField(r, TX_FIELDS.quantity));
    let amt = num(pickField(r, TX_FIELDS.amount));

    if (!Number.isFinite(amt)){
      const price = num(pickField(r, TX_FIELDS.price));
      if (Number.isFinite(price) && Number.isFinite(qty)) amt = price * qty;
    }

    if (!bySym.has(sym)) bySym.set(sym, { buys:0, sells:0 });

    if (action === "BUY"){
      if (Number.isFinite(amt)) bySym.get(sym).buys += Math.abs(amt);
      else warnings.push(`Missing amount for BUY row (symbol ${sym}).`);
    } else if (action === "SELL"){
      if (Number.isFinite(amt)) bySym.get(sym).sells += Math.abs(amt);
      else warnings.push(`Missing amount for SELL row (symbol ${sym}).`);
    }
  }

  return { bySym, warnings };
}

/** ========= PDF: Holdings-only parsing =========
  Strategy (works well for Fidelity statement format like yours):
  - Extract text lines per page
  - Track current account when we see "Account # XXXXX"
  - Turn "Holdings" ON when we see "Holdings" header
  - Turn holdings OFF when we see "Activity"
  - For any holdings row line containing "(TICKER)", parse numeric tokens and take the 4th number as "Ending Market Value"
    because table rows typically follow: Beginning Value, Quantity, Price, Ending Value, ...
**/
function parseEndDateFromText(allText){
  // Example seen: "December 1, 2024 - December 31, 2024"
  const m = allText.match(/-\s*(January|February|March|April|May|June|July|August|September|October|November|December)\s+(\d{1,2}),\s+(\d{4})/);
  if (!m) return null;
  const monthName = m[1], day = Number(m[2]), year = Number(m[3]);
  const monthMap = {January:0,February:1,March:2,April:3,May:4,June:5,July:6,August:7,September:8,October:9,November:10,December:11};
  return new Date(year, monthMap[monthName], day);
}
function ymd(d){
  const pad = (n)=>String(n).padStart(2,"0");
  return `${d.getFullYear()}-${pad(d.getMonth()+1)}-${pad(d.getDate())}`;
}
function extractLinesFromTextItems(textItems){
  // Reconstruct lines using y-position heuristic
  // PDF.js gives items with transform[5] as y; group close y's into same line.
  const items = textItems
    .map(it => ({ str: (it.str || "").trim(), x: it.transform?.[4] ?? 0, y: it.transform?.[5] ?? 0 }))
    .filter(it => it.str);

  items.sort((a,b) => (b.y - a.y) || (a.x - b.x));

  const lines = [];
  const yThreshold = 2.0; // tweak if needed
  let current = null;

  for (const it of items){
    if (!current || Math.abs(it.y - current.y) > yThreshold){
      if (current) lines.push(current.parts.join(" ").replace(/\s+/g," ").trim());
      current = { y: it.y, parts: [it.str] };
    } else {
      current.parts.push(it.str);
    }
  }
  if (current) lines.push(current.parts.join(" ").replace(/\s+/g," ").trim());
  return lines;
}
function parseHoldingsLine(line){
  // Must include "(TICKER)"
  const m = line.match(/\(([A-Z0-9.\-]{1,10})\)/);
  if (!m) return null;
  const symbol = m[1];

  // Pull numeric tokens (commas allowed). Keep decimals (2-4 decimals).
  const nums = [...line.matchAll(/-?\$?\d{1,3}(?:,\d{3})*(?:\.\d{2,4})?/g)]
    .map(x => x[0].replace(/\$/g,""))
    .map(x => Number(x.replace(/,/g,"")))
    .filter(v => Number.isFinite(v));

  // Fidelity holdings table rows typically: beginValue, quantity, price, endValue, ...
  // We want endValue -> 4th number (index 3).
  if (nums.length >= 4){
    return { symbol, endValue: nums[3] };
  }
  return null;
}

async function parsePdfHoldings(file){
  const arrayBuffer = await file.arrayBuffer();
  const loadingTask = pdfjsLib.getDocument({ data: arrayBuffer });
  const pdf = await loadingTask.promise;

  let allTextForDate = "";
  const bySymbol = new Map();

  let inHoldings = false;
  let currentAccount = null; // not used in aggregation yet, but kept for future account-level split.

  for (let p = 1; p <= pdf.numPages; p++){
    const page = await pdf.getPage(p);
    const content = await page.getTextContent();
    const lines = extractLinesFromTextItems(content.items);

    // Collect some text to infer end date (from first pages)
    if (p <= 2) allTextForDate += "\n" + lines.join("\n");

    for (const line of lines){
      const l = line;

      // account detection
      const acc = l.match(/Account\s*#\s*([A-Z0-9\-]{3,})/i);
      if (acc) currentAccount = acc[1];

      // holdings toggles
      if (/^\s*Holdings\b/i.test(l) || /\bHoldings\b/i.test(l) && /\bAccount\b/i.test(l)) inHoldings = true;
      if (/^\s*Activity\b/i.test(l) || /\bActivity\b/i.test(l)) inHoldings = false;

      if (!inHoldings) continue;

      // Must have "(TICKER)" and resemble a holdings row
      if (/\([A-Z0-9.\-]{1,10}\)/.test(l)){
        const parsed = parseHoldingsLine(l);
        if (parsed && Number.isFinite(parsed.endValue)){
          const sym = normSym(parsed.symbol);
          bySymbol.set(sym, (bySymbol.get(sym) || 0) + parsed.endValue);
        }
      }
    }
  }

  const endDate = parseEndDateFromText(allTextForDate);
  return {
    endDate,
    endDateLabel: endDate ? ymd(endDate) : "unknown-date",
    bySymbol,
    sourceName: file.name
  };
}

/** ========= Merge ========= **/
function mergeAllSnapshotsAndTx(){
  if (!snapshots.length){
    mergedRows = [];
    return;
  }

  // pick earliest as start, latest as end
  const sorted = [...snapshots].filter(s => s.endDate).sort((a,b)=>a.endDate - b.endDate);
  const startSnap = sorted[0] || snapshots[0];
  const endSnap = sorted[sorted.length-1] || snapshots[snapshots.length-1];

  const startMap = startSnap.bySymbol;
  const endMap = endSnap.bySymbol;

  const symbols = new Set([
    ...startMap.keys(),
    ...endMap.keys(),
    ...txAgg.bySym.keys()
  ]);

  const rows = [];
  for (const sym of symbols){
    const start = startMap.get(sym) || 0;
    const end = endMap.get(sym) || 0;
    const t = txAgg.bySym.get(sym) || { buys:0, sells:0 };
    const netFlow = (t.buys || 0) - (t.sells || 0);
    const growth = end - start - netFlow;

    rows.push({
      Symbol: sym,
      StartValue: start,
      EndValue: end,
      Buys: t.buys || 0,
      Sells: t.sells || 0,
      NetFlow: netFlow,
      MarketGrowth: growth
    });
  }

  rows.sort((a,b) => (b.MarketGrowth - a.MarketGrowth));
  mergedRows = rows;

  // Update snapshot info
  const info = sorted.length
    ? `start=${sorted[0].endDateLabel} (${sorted[0].sourceName}), end=${sorted[sorted.length-1].endDateLabel} (${sorted[sorted.length-1].sourceName})`
    : snapshots.map(s => `${s.endDateLabel} (${s.sourceName})`).join("; ");
  $("snapshotsInfo").textContent = info;
}

function renderAll(rows){
  // KPIs
  const totalStart = rows.reduce((s,r)=>s+r.StartValue,0);
  const totalEnd   = rows.reduce((s,r)=>s+r.EndValue,0);
  const totalFlow  = rows.reduce((s,r)=>s+r.NetFlow,0);
  const totalGrowth= rows.reduce((s,r)=>s+r.MarketGrowth,0);

  $("kpiStart").textContent = fmt(totalStart);
  $("kpiEnd").textContent = fmt(totalEnd);
  $("kpiFlow").textContent = fmt(totalFlow);
  $("kpiGrowth").textContent = fmt(totalGrowth);

  // Table
  const tbody = $("tbl").querySelector("tbody");
  tbody.innerHTML = "";
  for (const r of rows){
    const tr = document.createElement("tr");
    tr.innerHTML = `
      <td>${r.Symbol}</td>
      <td>${fmt(r.StartValue)}</td>
      <td>${fmt(r.EndValue)}</td>
      <td>${fmt(r.Buys)}</td>
      <td>${fmt(r.Sells)}</td>
      <td>${fmt(r.NetFlow)}</td>
      <td>${fmt(r.MarketGrowth)}</td>
    `;
    tbody.appendChild(tr);
  }
  $("tableNote").textContent = `Rows: ${rows.length}. Sorted by Market Growth (desc).`;

  // Charts
  const top = rows.slice(0, 12).filter(r => r.Symbol);
  const labels = top.map(r => r.Symbol);
  const values = top.map(r => r.MarketGrowth);

  if (growthChart) growthChart.destroy();
  growthChart = new Chart($("growthChart"), {
    type: "bar",
    data: { labels, datasets: [{ label:"Market Growth", data: values }] },
    options: { responsive:true, plugins:{ legend:{ display:false } } }
  });

  const totalBuys = rows.reduce((s,r)=>s+r.Buys,0);
  const totalSells= rows.reduce((s,r)=>s+r.Sells,0);

  if (flowChart) flowChart.destroy();
  flowChart = new Chart($("flowChart"), {
    type: "doughnut",
    data: { labels:["Buys","Sells"], datasets:[{ data:[totalBuys,totalSells] }] },
    options: { responsive:true }
  });
}

function exportCsv(rows){
  const header = ["Symbol","StartValue","EndValue","Buys","Sells","NetFlow","MarketGrowth"];
  const lines = [header.join(",")].concat(
    rows.map(r => header.map(h => {
      const v = r[h];
      return (typeof v === "number") ? v.toFixed(2) : String(v ?? "");
    }).join(","))
  );
  const blob = new Blob([lines.join("\n")], {type:"text/csv;charset=utf-8"});
  const url = URL.createObjectURL(blob);
  const a = document.createElement("a");
  a.href = url;
  a.download = "portfolio_overview.csv";
  document.body.appendChild(a);
  a.click();
  a.remove();
  URL.revokeObjectURL(url);
}

/** ========= Actions ========= **/
async function processUploads(files){
  warn("");
  setStatus("Processing…");

  // Reset only computed state, keep existing if you want incremental
  snapshots = [];
  txAgg = { bySym: new Map(), warnings: [] };

  let txLoaded = 0;
  let pdfLoaded = 0;

  for (const f of files){
    const name = (f.name || "").toLowerCase();
    try{
      if (name.endsWith(".csv")){
        // transactions CSV
        const text = await f.text();
        const parsed = Papa.parse(text, { header:true, skipEmptyLines:true });
        const agg = parseTransactionsCsv(parsed.data || []);
        txAgg = agg;
        txLoaded++;
      } else if (name.endsWith(".pdf")){
        // holdings-only PDF
        const snap = await parsePdfHoldings(f);
        if (!snap.bySymbol.size){
          warn(( $("warnBox").textContent ? $("warnBox").textContent + "\n" : "" ) +
               `PDF parsed but no holdings rows found in ${f.name}. (If this is a scanned PDF, text extraction may fail.)`);
        }
        snapshots.push(snap);
        pdfLoaded++;
      } else {
        warn(( $("warnBox").textContent ? $("warnBox").textContent + "\n" : "" ) +
             `Skipped unsupported file: ${f.name}`);
      }
    } catch(e){
      console.error(e);
      warn(( $("warnBox").textContent ? $("warnBox").textContent + "\n" : "" ) +
           `Error processing ${f.name}: ${e?.message || e}`);
    }
  }

  $("txInfo").textContent = txLoaded ? "loaded" : "none";

  // Sort snapshots by endDate (if available)
  snapshots.sort((a,b)=>{
    if (!a.endDate && !b.endDate) return 0;
    if (!a.endDate) return 1;
    if (!b.endDate) return -1;
    return a.endDate - b.endDate;
  });

  if (snapshots.length){
    $("snapshotsInfo").textContent = snapshots.map(s => `${s.endDateLabel} (${s.sourceName})`).join("; ");
  } else {
    $("snapshotsInfo").textContent = "none";
  }

  mergeAllSnapshotsAndTx();
  renderAll(mergedRows);

  // warnings
  const w = [];
  if (txAgg.warnings?.length) w.push("CSV warnings: " + txAgg.warnings.slice(0,6).join(" | "));
  if (snapshots.length < 2) w.push("Tip: upload two statements (e.g., 12/31/2024 and 12/31/2025) to compute growth.");
  warn(w.join("\n"));

  setStatus(`Done (PDF: ${pdfLoaded}, CSV: ${txLoaded})`);
}

$("processBtn").addEventListener("click", async () => {
  const files = $("fileInput").files;
  if (!files || !files.length){
    setStatus("Missing files");
    warn("Please select at least one PDF statement and/or a transactions CSV.");
    return;
  }
  await processUploads([...files]);
});

$("resetBtn").addEventListener("click", () => {
  $("fileInput").value = "";
  snapshots = [];
  txAgg = { bySym:new Map(), warnings:[] };
  mergedRows = [];
  $("snapshotsInfo").textContent = "none";
  $("txInfo").textContent = "none";
  $("kpiStart").textContent = "—";
  $("kpiEnd").textContent = "—";
  $("kpiFlow").textContent = "—";
  $("kpiGrowth").textContent = "—";
  $("tbl").querySelector("tbody").innerHTML = "";
  $("tableNote").textContent = "";
  warn("");
  if (growthChart) growthChart.destroy();
  if (flowChart) flowChart.destroy();
  setStatus("Waiting for uploads…");
});

$("loadDemoBtn").addEventListener("click", () => {
  // Demo snapshots: 2024-12-31 and 2025-12-31
  snapshots = [
    { endDate: new Date(2024,11,31), endDateLabel:"2024-12-31", sourceName:"demo_2024.pdf", bySymbol: new Map([["MSFT", 337216],["VOO", 93585],["FXAIX",37271],["FBGRX",31480],["SMH",10999],["SPAXX",81.61]]) },
    { endDate: new Date(2025,11,31), endDateLabel:"2025-12-31", sourceName:"demo_2025.pdf", bySymbol: new Map([["MSFT", 420000],["VOO", 110000],["FXAIX",40000],["FBGRX",33000],["SMH",15000],["SPAXX",500]]) }
  ];
  txAgg = { bySym: new Map([
    ["MSFT",{buys:20000,sells:0}],
    ["VOO",{buys:5000,sells:0}],
    ["SMH",{buys:0,sells:2000}]
  ]), warnings: [] };

  $("txInfo").textContent = "loaded (demo)";
  $("snapshotsInfo").textContent = snapshots.map(s => `${s.endDateLabel} (${s.sourceName})`).join("; ");
  mergeAllSnapshotsAndTx();
  renderAll(mergedRows);
  warn("Demo loaded.");
  setStatus("Demo ready");
});

$("exportBtn").addEventListener("click", () => exportCsv(mergedRows));

$("searchBox").addEventListener("input", (e) => {
  const q = normSym(e.target.value);
  if (!q){ renderAll(mergedRows); return; }
  renderAll(mergedRows.filter(r => r.Symbol.includes(q)));
});
</script>
</body>
</html>
